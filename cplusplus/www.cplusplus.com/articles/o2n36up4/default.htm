<!DOCTYPE html><!-- saved from url=(0054)http://www.cplusplus.com/articles/o2n36up4/default.htm --><meta http-equiv="X-UA-Compatible" content="IE=Edge" />

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Simple port scanner - C++ Articles</title>
<link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico">
<link rel="stylesheet" type="text/css" href="../../v321/main.css">
<script src="../../v321/main.js" type="text/javascript"></script>
</head>
<body>
<div id="I_top">
<div id="I_header">
<div id="I_logo"><a href="../../default.htm" title="cplusplus.com"><div></div></a></div>
<div id="I_search">
<form id="search" action="/search.do" method="get">
Search: <input name="q" size="20" class="txt"> <input type="submit" value="Go" class="btn">
</form>
</div>
<div id="I_bar">
<ul>
<li><a href="../default.htm">Articles</a></li>
<li class="here">Simple port scanner</li>
</ul>
</div>
<div id="I_user" class="C_LoginBox"><span title="ajax"></span></div>
</div>
</div>
<div id="I_mid">
<div id="I_wrap">
<div id="I_minheight"></div>
<div id="I_main">
<div id="I_content">
<div class="C_art">
<div id="I_author">Published by <b><a href="../../user/chrisname/default.htm" rel="author">chrisname</a></b></div>
<div id="I_date">Apr 16, 2013 (last update: Apr 17, 2013)</div>
<h1>Simple port scanner</h1>
<div id="I_score">Score: 4.4/5 (95 votes)</div>
<div id="I_stars"><img src="../../ico/16star.png" width="16" height="16" alt="*"><img src="../../ico/16star.png" width="16" height="16" alt="*"><img src="../../ico/16star.png" width="16" height="16" alt="*"><img src="../../ico/16star.png" width="16" height="16" alt="*"><img src="../../ico/16star-empty.png" width="16" height="16" alt="*"></div>
<div id="I_content">
<h3>Prerequisites</h3>
<ul>
<li>SFML 2.0 Release Candidate: [ <a href="../../../sfml-dev.org/download.php#2.0-rc">download</a> | <a href="../../../sfml-dev.org/documentation/2.0/default.htm">documentation</a> | <a href="../../../sfml-dev.org/tutorials/2.0/default.htm">tutorial</a> ]<br>
<li>Templates [ <a href="../../../cplusplus.com/doc/tutorial/templates/default.htm">tutorial</a> ]</li>
<li>std::vector [ <a href="../../../cplusplus.com/reference/vector/vector/default.htm">documentation</a> ]</li>
<li>std::stringstream [ <a href="../../../cplusplus.com/reference/sstream/stringstream/default.htm">documentation</a> ]</li>
<li>The C++11 range-based for loop [ <a href="../../../en.wikipedia.org/wiki/c11#Range-based_for-loop">Wikipedia</a> ]</li>
</ul>
<br>
<h3>Introduction</h3>
<br>
A port scanner is a program which probes a server for open ports by attempting a connection to the server via each port in turn. The program usually then reports which ports were open and which were closed. More complex port scanners, such as Nmap, can probe for other information as well. Port scanning is usually performed by system administrators to verify network security or by attackers looking for an open port through which to compromise the security of a server. Open ports may constitute security vulnerabilities as they allow remote machines to connect. Unexpectedly-open ports may indicate malicious software listening for instructions.<br>
<br>
<h3>My First Port Scanner</h3>
<br>
As before, scanning ports is as simple as attempting a connection to an address and port. If the connection attempt is successful, the port must be open. Otherwise the port is presumed to be closed. Here is an example function using the SFML Network module (<a href="../../../sfml-dev.org/documentation/2.0/group__network.php">documentation</a>) to check if a port is open:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br></code></pre></td>
<td class="source"><pre><code><var>bool</var> port_is_open(<var>const</var> std::string&amp; address, <var>int</var> port)
{
    sf::TcpSocket socket;
    <var>bool</var> open = (socket.connect(sf::IpAddress(address), port) == sf::Socket::Done);
    socket.disconnect();
    <var>return</var> open;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Breakdown:<br>
<ol>
<li>First, we create an instance of sf::TcpSocket (<a href="../../../sfml-dev.org/documentation/2.0/classsf_1_1tcpsocket.php">documentation</a>) which allows us to connect to a remote socket</li>
<li>Then, we connect the socket. We convert the string 'address' to an sf::IpAddress (<a href="../../../sfml-dev.org/documentation/2.0/classsf_1_1ipaddress.php">documentation</a>) instance by calling the constructor for sf::IpAddress. If the explicit constructor call is left out, it will be performed implicitly by the compiler anyway. After attempting a connection we check whether the connection succeeded by comparing the return value of the sf::TcpSocket::connect function (<a href="../../../sfml-dev.org/documentation/2.0/classsf_1_1tcpsocket.php#a68cd42d5ab70ab54b16787f555951c40">documentation</a>) with the enumerator value sf::Socket::Done (<a href="../../../sfml-dev.org/documentation/2.0/classsf_1_1socket.php#a51bf0fd51057b98a10fbb866246176dc">documentation</a>). If the two are equal, it means the connection succeeded and the port is open. In this case, the variable 'open' is set to true.</li>
<li>Next, we disconnect the socket using the sf::TcpSocket::disconnect function (<a href="../../../sfml-dev.org/documentation/2.0/classsf_1_1tcpsocket.php#a68cd42d5ab70ab54b16787f555951c40">documentation</a>). This would be done automatically in the destructor if we left the explicit call out.</li>
<li>Finally, we return the value of 'open' to the calling function.</li>
</ol>
This is actually the only networking code we need to write. We can also simplify it to a single line:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>static</var> <var>bool</var> port_is_open(<var>const</var> std::string&amp; address, <var>int</var> port)
{
    <var>return</var> (sf::TcpSocket().connect(address, port) == sf::Socket::Done);
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
Here we're creating a new sf::TcpSocket, connecting to the address and port and then returning true or false depending on whether the connection succeeded. We get rid of the unneeded explicit sf::IpAddress constructor call as well as the call to sf::TcpSocket::disconnect(). We can use the function in a program like this:<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br></code></pre></td>
<td class="source"><pre><code><dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;SFML/Network.hpp&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>

<var>static</var> <var>bool</var> port_is_open(<var>const</var> std::string&amp; address, <var>int</var> port)
{
    <var>return</var> (sf::TcpSocket().connect(address, port) == sf::Socket::Done);
}

<var>int</var> main()
{
    std::cout &lt;&lt; <kbd>"Port 80 : "</kbd>;
    <var>if</var> (port_is_open(<kbd>"localhost"</kbd>, 80))
        std::cout &lt;&lt; <kbd>"OPEN"</kbd> &lt;&lt; std::endl;
    <var>else</var>
        std::cout &lt;&lt; <kbd>"CLOSED"</kbd> &lt;&lt; std::endl;
    <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>Port 80 : OPEN</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
Try compiling and running this program. It will test if port 80 on your computer is open. Note that "localhost" means the local computer; you can also use the IP address 127.0.0.1 or ::1 (the IPv6 version, although SFML does not yet support IPv6) for the same purpose. You can change "localhost" to the IP address or web address of another website (leaving out the "http://" and any path information), but be careful - <b>portscanning websites without permission can get you into trouble</b> in some countries as it can be considered hacking. Luckily the website of the port scanner Nmap has a page specifically for testing port scanners. Try changing "localhost" to "scanme.nmap.org". Just don't scan it too much (the page says "a few times per day").<br>
<br>
<h3>Improved Port Scanner</h3>
<br>
Now that we've successfully developed a program that can scan a port on an address, we can modify our program to let the user specify a port and address to scan:<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br></code></pre></td>
<td class="source"><pre><code><dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;SFML/Network.hpp&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>

<var>static</var> <var>bool</var> port_is_open(<var>const</var> std::string&amp; address, <var>int</var> port)
{
    <var>return</var> (sf::TcpSocket().connect(address, port) == sf::Socket::Done);
}


<var>int</var> main()
{
    std::string address;
    <var>int</var> port;
    <cite>// Get the address.</cite>
    std::cout &lt;&lt; <kbd>"Address: "</kbd> &lt;&lt; std::flush;
    std::getline(std::cin, address);
    <cite>// Get the port.</cite>
    std::cout &lt;&lt; <kbd>"Port: "</kbd> &lt;&lt; std::flush;
    std::cin &gt;&gt; port;
    <cite>// Scan!</cite>
    std::cout &lt;&lt; <kbd>"Scanning "</kbd> &lt;&lt; address &lt;&lt; <kbd>"...\n"</kbd> &lt;&lt; <kbd>"Port "</kbd> &lt;&lt; port &lt;&lt; <kbd>" : "</kbd>;
    <var>if</var> (port_is_open(address, port))
        std::cout &lt;&lt; <kbd>"OPEN"</kbd> &lt;&lt; std::endl;
    <var>else</var>
        std::cout &lt;&lt; <kbd>"CLOSED"</kbd> &lt;&lt; std::endl;
    <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>Address: 127.0.0.1
Port: 80
Scanning 127.0.0.1...
Port 80 : OPEN</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
Remember that 127.0.0.1 is equivalent to localhost. Also, port 80 may not be open on your computer. It's only open on mine because I'm running Apache HTTP server (port 80 is the main port commonly used for HTTP, i.e. websites; the other port commonly used for HTTP is port 8080).<br>
<br>
Also, we can easily test this code on Nmap's "ScanMe" page:<br>
<div class="auto"><table class="snippet"><tr><td class="output"><pre><samp>Address: scanme.nmap.org
Port: 80
Scanning scanme.nmap.org...
Port 80 : OPEN</samp></pre></td></tr></table></div>
It might take slightly longer this time because you aren't scanning your own computer, this time you're connecting to another computer via the Internet.<br>
<br>
<h3>A Fistful of Ports</h3>
<br>
Scanning one port at a time is tedious, we want to let the user scan lots of ports. One way to do this would be to let the user enter as many ports as they want and then have them all scanned in one go. The problem with this is that the user might want to scan a lot of ports, and would have to enter each one. We could also let the user specify a range of ports, say, 0-100, but then they couldn't specify values outside of that range. We're going to go one better and let them do both - specify ranges AND individual ports in a list like this: '80,8080'; a range, like this: '20-80'; or a list containing ranges: '20-80,8080'. This code gets kind of complex due to the use of templates, std::vector, std::stringstream and the C++11 range-based for-loop, so if you skipped the "prerequisites" section and don't know how to use those, go back to the top of this article and learn. Otherwise, read on.<br>
<br>
First we need a function to split strings:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br></code></pre></td>
<td class="source"><pre><code><cite>// Splits a string into tokens arround a delimiter (default: space),</cite>
<cite>// optionally allowing empty tokens.</cite>
<var>static</var> std::vector&lt;std::string&gt; split(<var>const</var> std::string&amp; string,
                                      <var>char</var> delimiter = <kbd>' '</kbd>,
                                      <var>bool</var> allow_empty = <var>false</var>)
{
    std::vector&lt;std::string&gt; tokens;
    std::stringstream sstream(string);
    std::string token;
    <var>while</var> (std::getline(sstream, token, delimiter)) {
        <var>if</var> (allow_empty || token.size() &gt; 0)
            tokens.push_back(token);
    }
    <var>return</var> tokens;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The data type of the ports will be a string, but we want an integer, so we will also need a function to convert strings to integers:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br></code></pre></td>
<td class="source"><pre><code><cite>// Converts a string to an integer.</cite>
<var>static</var> <var>int</var> string_to_int(<var>const</var> std::string&amp; string)
{
    std::stringstream sstream(string);
    <var>int</var> i;
    sstream &gt;&gt; i;
    <var>return</var> i;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
If we have a range of ports, we will need a function to generate all the values in that range:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br></code></pre></td>
<td class="source"><pre><code><cite>// Swaps two values.</cite>
<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> <var>void</var> swap(T&amp; a, T&amp; b)
{
    T c = a;
    a = b;
    b = c;
}

<cite>// Generates a vector containing a range of values.</cite>
<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> std::vector&lt;T&gt; range(T min, T max)
{
    <var>if</var> (min &gt; max)
        swap(min, max);
    <var>if</var> (min == max)
        <var>return</var> std::vector&lt;T&gt;(1, min);
    std::vector&lt;T&gt; values;
    <var>for</var> (; min &lt;= max; ++min)
        values.push_back(min);
    <var>return</var> values;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Finally, we need a function to actually parse the list of ports using the above functions:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br></code></pre></td>
<td class="source"><pre><code><cite>// Parses a list of ports containing numbers and ranges</cite>
<var>static</var> std::vector&lt;<var>int</var>&gt; parse_ports_list(<var>const</var> std::string&amp; list)
{
    std::vector&lt;<var>int</var>&gt; ports;
    <cite>// Split list items.</cite>
    <var>for</var> (<var>const</var> std::string&amp; token : split(list, <kbd>','</kbd>)) {
        <cite>// Split ranges.</cite>
        std::vector&lt;std::string&gt; strrange = split(token, <kbd>'-'</kbd>);
        <var>switch</var> (strrange.size()) {
            <cite>// Only one value (add to end of 'ports').</cite>
            <var>case</var> 0: ports.push_back(string_to_int(token));       <var>break</var>;
            <var>case</var> 1: ports.push_back(string_to_int(strrange[0])); <var>break</var>;
            <cite>// Two values (range - add everything in that range).</cite>
            <var>case</var> 2:
            {
                <var>int</var> min = string_to_int(strrange[0]),
                    max = string_to_int(strrange[1]);
                <var>for</var> (<var>int</var> port : range(min, max))
                    ports.push_back(port);
                <var>break</var>;
            }
            <var>default</var>:
                <var>break</var>;
        }
    }
    <var>return</var> ports;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Our finished program:<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br></code></pre></td>
<td class="source"><pre><code><dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;SFML/Network.hpp&gt;</dfn>
<dfn>#include &lt;sstream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<dfn>#include &lt;vector&gt;</dfn>

<var>static</var> <var>bool</var> port_is_open(<var>const</var> std::string&amp; address, <var>int</var> port)
{
    <var>return</var> (sf::TcpSocket().connect(address, port) == sf::Socket::Done);
}


<var>static</var> std::vector&lt;std::string&gt; split(<var>const</var> std::string&amp; string,
                                      <var>char</var> delimiter = <kbd>' '</kbd>,
                                      <var>bool</var> allow_empty = <var>false</var>)
{
    std::vector&lt;std::string&gt; tokens;
    std::stringstream sstream(string);
    std::string token;
    <var>while</var> (std::getline(sstream, token, delimiter)) {
        <var>if</var> (allow_empty || token.size() &gt; 0)
            tokens.push_back(token);
    }
    <var>return</var> tokens;
}

<var>static</var> <var>int</var> string_to_int(<var>const</var> std::string&amp; string)
{
    std::stringstream sstream(string);
    <var>int</var> i;
    sstream &gt;&gt; i;
    <var>return</var> i;
}

<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> <var>void</var> swap(T&amp; a, T&amp; b)
{
    T c = a;
    a = b;
    b = c;
}

<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> std::vector&lt;T&gt; range(T min, T max)
{
    <var>if</var> (min &gt; max)
        swap(min, max);
    <var>if</var> (min == max)
        <var>return</var> std::vector&lt;T&gt;(1, min);
    std::vector&lt;T&gt; values;
    <var>for</var> (; min &lt;= max; ++min)
        values.push_back(min);
    <var>return</var> values;
}

<var>static</var> std::vector&lt;<var>int</var>&gt; parse_ports_list(<var>const</var> std::string&amp; list)
{
    std::vector&lt;<var>int</var>&gt; ports;
    <var>for</var> (<var>const</var> std::string&amp; token : split(list, <kbd>','</kbd>)) {
        std::vector&lt;std::string&gt; strrange = split(token, <kbd>'-'</kbd>);
        <var>switch</var> (strrange.size()) {
            <var>case</var> 0: ports.push_back(string_to_int(token));       <var>break</var>;
            <var>case</var> 1: ports.push_back(string_to_int(strrange[0])); <var>break</var>;
            <var>case</var> 2:
            {
                <var>int</var> min = string_to_int(strrange[0]),
                    max = string_to_int(strrange[1]);
                <var>for</var> (<var>int</var> port : range(min, max))
                    ports.push_back(port);
                <var>break</var>;
            }
            <var>default</var>:
                <var>break</var>;
        }
    }
    <var>return</var> ports;
}

<var>int</var> main()
{
    std::string address;
    std::string port_list;
    std::vector&lt;<var>int</var>&gt; ports;
    std::cout &lt;&lt; <kbd>"Address: "</kbd> &lt;&lt; std::flush;
    std::getline(std::cin, address);
    std::cout &lt;&lt; <kbd>"Port: "</kbd> &lt;&lt; std::flush;
    std::getline(std::cin, port_list);
    ports = parse_ports_list(port_list);
    std::cout &lt;&lt; <kbd>"Scanning "</kbd> &lt;&lt; address &lt;&lt; <kbd>"...\n"</kbd>;
    <var>for</var> (<var>int</var> port : ports) {
        std::cout &lt;&lt; <kbd>"Port "</kbd> &lt;&lt; port &lt;&lt; <kbd>" : "</kbd>;
        <var>if</var> (port_is_open(address, port))
            std::cout &lt;&lt; <kbd>"OPEN\n"</kbd>;
        <var>else</var>
            std::cout &lt;&lt; <kbd>"CLOSED\n"</kbd>;
    }
    std::cout &lt;&lt; std::flush;
    <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>Address: 127.0.0.1
Port: 20-80,8080
Scanning 127.0.0.1...
Port 20 : CLOSED
Port 21 : CLOSED
Port 22 : OPEN
Port 23 : CLOSED
Port 24 : CLOSED
Port 25 : CLOSED
Port 26 : CLOSED
Port 27 : CLOSED
Port 28 : CLOSED
Port 29 : CLOSED
Port 30 : CLOSED
Port 31 : CLOSED
Port 32 : CLOSED
Port 33 : CLOSED
Port 34 : CLOSED
Port 35 : CLOSED
Port 36 : CLOSED
Port 37 : CLOSED
Port 38 : CLOSED
Port 39 : CLOSED
Port 40 : CLOSED
Port 41 : CLOSED
Port 42 : CLOSED
Port 43 : CLOSED
Port 44 : CLOSED
Port 45 : CLOSED
Port 46 : CLOSED
Port 47 : CLOSED
Port 48 : CLOSED
Port 49 : CLOSED
Port 50 : CLOSED
Port 51 : CLOSED
Port 52 : CLOSED
Port 53 : OPEN
Port 54 : CLOSED
Port 55 : CLOSED
Port 56 : CLOSED
Port 57 : CLOSED
Port 58 : CLOSED
Port 59 : CLOSED
Port 60 : CLOSED
Port 61 : CLOSED
Port 62 : CLOSED
Port 63 : CLOSED
Port 64 : CLOSED
Port 65 : CLOSED
Port 66 : CLOSED
Port 67 : CLOSED
Port 68 : CLOSED
Port 69 : CLOSED
Port 70 : CLOSED
Port 71 : CLOSED
Port 72 : CLOSED
Port 73 : CLOSED
Port 74 : CLOSED
Port 75 : CLOSED
Port 76 : CLOSED
Port 77 : CLOSED
Port 78 : CLOSED
Port 79 : CLOSED
Port 80 : OPEN
Port 8080 : CLOSED</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
Et voila! We now have a successful port scanner which can scan any number of ports the user desires.<br>
<br>
<h3>For a Few Ports More</h3>
<br>
Our program can be modified not to show closed ports by changing<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br></code></pre></td>
<td class="source"><pre><code>    std::cout &lt;&lt; <kbd>"Scanning "</kbd> &lt;&lt; address &lt;&lt; <kbd>"...\n"</kbd>;
    <var>for</var> (<var>int</var> port : ports) {
        std::cout &lt;&lt; <kbd>"Port "</kbd> &lt;&lt; port &lt;&lt; <kbd>" : "</kbd>;
        <var>if</var> (port_is_open(address, port))
            std::cout &lt;&lt; <kbd>"OPEN\n"</kbd>;
        <var>else</var>
            std::cout &lt;&lt; <kbd>"CLOSED\n"</kbd>;
    }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
to<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>89<br>90<br>91<br>92<br>93<br></code></pre></td>
<td class="source"><pre><code>    std::cout &lt;&lt; <kbd>"Showing open ports on "</kbd> &lt;&lt; address &lt;&lt; <kbd>"...\n"</kbd>;
    <var>for</var> (<var>int</var> port : ports) {
        <var>if</var> (port_is_open(address, port))
            std::cout &lt;&lt; <kbd>"Port "</kbd> &lt;&lt; port &lt;&lt; <kbd>" : OPEN\n"</kbd>;
    }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
This makes the output far more legible. Scanning every port on my computer:<br>
<div class="auto"><table class="snippet"><tr><td class="output"><pre><samp>Address: localhost
Port: 0-65535
Showing open ports on localhost...
Port 22 : OPEN
Port 53 : OPEN
Port 80 : OPEN
Port 139 : OPEN
Port 445 : OPEN
Port 631 : OPEN
Port 3306 : OPEN
Port 17500 : OPEN</samp></pre></td></tr></table></div>
Note that there are 65535 ports. If we scanned all of them with the previous version of the port scanner, it would produce 65,535 lines of output which would make it very difficult to get the desired information.<br>
<br>
We can format our output nicely by adding <span class="auto"><code class="source"><dfn>#include &lt;iomanip&gt; </dfn></code></span> at the top of the file, and <span class="auto"><code class="source">size_t width = digits(maximum(ports));</code></span> just before the for-loop in the main function, and then changing the line that displays the port status to <span class="auto"><code class="source">std::cout &lt;&lt; <kbd>"Port "</kbd> &lt;&lt; std::setw(width) &lt;&lt; port &lt;&lt; <kbd>" : OPEN\n"</kbd>;</code></span>. You will also need to add these two functions just before main:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br></code></pre></td>
<td class="source"><pre><code><cite>// Gets the maximum value in a vector.</cite>
<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> T maximum(<var>const</var> std::vector&lt;T&gt;&amp; values)
{
    T max = values[0];
    <var>for</var> (T value : values) {
        <var>if</var> (value &gt; max)
            max = value;
    }
    <var>return</var> max;
}

<cite>// Counts the digits in a number.</cite>
<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> size_t digits(T value)
{
    size_t count = (value &lt; 0) ? 1 : 0;
    <var>if</var> (value == 0)
        <var>return</var> 0;
    <var>while</var> (value) {
        value /= 10;
        ++count;
    };
    <var>return</var> count;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Now the output will be nicely formatted:<br>
<div class="auto"><table class="snippet"><tr><td class="output"><pre><samp>Address: localhost
Port: 0-65535
Showing open ports on localhost...
Port    22 : OPEN
Port    53 : OPEN
Port    80 : OPEN
Port   139 : OPEN
Port   445 : OPEN
Port   631 : OPEN
Port  3306 : OPEN
Port 17500 : OPEN
Port 35723 : OPEN
Port 43351 : OPEN</samp></pre></td></tr></table></div>
<br>
Here is the code for our improved port scanner:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br></code></pre></td>
<td class="source"><pre><code><dfn>#include &lt;cstdlib&gt;</dfn>
<dfn>#include &lt;iomanip&gt;</dfn>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;SFML/Network.hpp&gt;</dfn>
<dfn>#include &lt;sstream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<dfn>#include &lt;vector&gt;</dfn>

<var>static</var> <var>bool</var> port_is_open(<var>const</var> std::string&amp; address, <var>int</var> port)
{
    <var>return</var> (sf::SocketTCP().connect(address, port) == sf::Socket::Done);
}

<var>static</var> std::vector&lt;std::string&gt; split(<var>const</var> std::string&amp; string,
                                      <var>char</var> delimiter = <kbd>' '</kbd>,
                                      <var>bool</var> allow_empty = <var>false</var>)
{
    std::vector&lt;std::string&gt; tokens;
    std::stringstream sstream(string);
    std::string token;
    <var>while</var> (std::getline(sstream, token, delimiter)) {
        <var>if</var> (allow_empty || token.size() &gt; 0)
            tokens.push_back(token);
    }
    <var>return</var> tokens;
}

<var>static</var> <var>int</var> string_to_int(<var>const</var> std::string&amp; string)
{
    std::stringstream sstream(string);
    <var>int</var> i;
    sstream &gt;&gt; i;
    <var>return</var> i;
}

<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> <var>void</var> swap(T&amp; a, T&amp; b)
{
    T c = a;
    a = b;
    b = c;
}

<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> std::vector&lt;T&gt; range(T min, T max)
{
    <var>if</var> (min &gt; max)
        swap(min, max);
    <var>if</var> (min == max)
        <var>return</var> std::vector&lt;T&gt;(1, min);
    std::vector&lt;T&gt; values;
    <var>for</var> (; min &lt;= max; ++min)
        values.push_back(min);
    <var>return</var> values;
}

<var>static</var> std::vector&lt;<var>int</var>&gt; parse_ports_list(<var>const</var> std::string&amp; list)
{
    std::vector&lt;<var>int</var>&gt; ports;
    <var>for</var> (<var>const</var> std::string&amp; token : split(list, <kbd>','</kbd>)) {
        std::vector&lt;std::string&gt; strrange = split(token, <kbd>'-'</kbd>);
        <var>switch</var> (strrange.size()) {
            <var>case</var> 0: ports.push_back(string_to_int(token));       <var>break</var>;
            <var>case</var> 1: ports.push_back(string_to_int(strrange[0])); <var>break</var>;
            <var>case</var> 2:
            {
                <var>int</var> min = string_to_int(strrange[0]),
                    max = string_to_int(strrange[1]);
                <var>for</var> (<var>int</var> port : range(min, max))
                    ports.push_back(port);
                <var>break</var>;
            }
            <var>default</var>:
                <var>break</var>;
        }
    }
    <var>return</var> ports;
}

<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> T maximum(<var>const</var> std::vector&lt;T&gt;&amp; values)
{
    T max = values[0];
    <var>for</var> (T value : values) {
        <var>if</var> (value &gt; max)
            max = value;
    }
    <var>return</var> max;
}

<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> size_t digits(T value)
{
    size_t count = (value &lt; 0) ? 1 : 0;
    <var>if</var> (value == 0)
        <var>return</var> 0;
    <var>while</var> (value) {
        value /= 10;
        ++count;
    };
    <var>return</var> count;
}

<var>int</var> main()
{
    std::string address;
    std::string port_list;
    std::vector&lt;<var>int</var>&gt; ports;
    std::cout &lt;&lt; <kbd>"Address: "</kbd> &lt;&lt; std::flush;
    std::getline(std::cin, address);
    std::cout &lt;&lt; <kbd>"Port: "</kbd> &lt;&lt; std::flush;
    std::getline(std::cin, port_list);
    ports = parse_ports_list(port_list);
    std::cout &lt;&lt; <kbd>"Showing open ports on "</kbd> &lt;&lt; address &lt;&lt; <kbd>"...\n"</kbd>;
    size_t width = digits(maximum(ports));
    <var>for</var> (<var>int</var> port : ports) {
        <var>if</var> (port_is_open(address, port))
            std::cout &lt;&lt; <kbd>"Port "</kbd> &lt;&lt; std::setw(width) &lt;&lt; port &lt;&lt; <kbd>" : OPEN\n"</kbd>;
    }
    std::cout &lt;&lt; std::flush;
    <var>return</var> 0;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
You may want to be able to use the program easily in scripts and run it easily from other programs, in which case you can modify it to use command-line for the address and port information. Here is a modified main function:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br></code></pre></td>
<td class="source"><pre><code><var>int</var> main(<var>int</var> argc, <var>char</var>* argv[])
{
    <var>if</var> (argc != 3) {
        std::cerr &lt;&lt; <kbd>"Usage: "</kbd> &lt;&lt; argv[0] &lt;&lt; <kbd>" address port(s)\n"</kbd>
                  &lt;&lt; <kbd>"Examples:\n"</kbd>
                  &lt;&lt; <kbd>"\t"</kbd> &lt;&lt; argv[0] &lt;&lt; <kbd>" 127.0.0.1 80\n"</kbd>
                  &lt;&lt; <kbd>"\t"</kbd> &lt;&lt; argv[0] &lt;&lt; <kbd>" localhost 80,8080\n"</kbd>
                  &lt;&lt; <kbd>"\t"</kbd> &lt;&lt; argv[0] &lt;&lt; <kbd>" 192.0.43.10 0-65535\n"</kbd>
                  &lt;&lt; <kbd>"\t"</kbd> &lt;&lt; argv[0] &lt;&lt; <kbd>" example.com 0-21,80,8080"</kbd>
                  &lt;&lt; std::endl;
        std::exit(EXIT_FAILURE);
    }
    std::string address = argv[1];
    std::vector&lt;<var>int</var>&gt; ports = parse_ports_list(std::string(argv[2]));
    std::cout &lt;&lt; <kbd>"Showing open ports on "</kbd> &lt;&lt; address &lt;&lt; <kbd>"...\n"</kbd>;
    size_t width = digits(maximum(ports));
    <var>for</var> (<var>int</var> port : ports) {
        <var>if</var> (port_is_open(address, port))
            std::cout &lt;&lt; <kbd>"Port "</kbd> &lt;&lt; std::setw(width) &lt;&lt; port &lt;&lt; <kbd>" : OPEN\";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
} </kbd></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
And here is one that allows both:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br></code></pre></td>
<td class="source"><pre><code><var>int</var> main(<var>int</var> argc, <var>char</var>* argv[])
{
    std::string address;
    std::vector&lt;<var>int</var>&gt; ports;
    <var>if</var> (argc == 3) {
        address = argv[1];
        ports = parse_ports_list(std::string(argv[2]));
    } <var>else</var> {
        std::string port_list;
        std::cout &lt;&lt; <kbd>"Address: "</kbd> &lt;&lt; std::flush;
        std::getline(std::cin, address);
        std::cout &lt;&lt; <kbd>"Port: "</kbd> &lt;&lt; std::flush;
        std::getline(std::cin, port_list);
        ports = parse_ports_list(port_list);
    }
    std::cout &lt;&lt; <kbd>"Showing open ports on "</kbd> &lt;&lt; address &lt;&lt; <kbd>"...\n"</kbd>;
    size_t width = digits(maximum(ports));
    <var>for</var> (<var>int</var> port : ports) {
        <var>if</var> (port_is_open(address, port))
            std::cout &lt;&lt; <kbd>"Port "</kbd> &lt;&lt; std::setw(width) &lt;&lt; port &lt;&lt; <kbd>" : OPEN\n"</kbd>;
    }
    std::cout &lt;&lt; std::flush;
    <var>return</var> 0;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here is the final (for now) iteration of the port scanner, which allows both command-line and interactive invocation:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br></code></pre></td>
<td class="source"><pre><code><dfn>#include &lt;cstdlib&gt;</dfn>
<dfn>#include &lt;iomanip&gt;</dfn>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;SFML/Network.hpp&gt;</dfn>
<dfn>#include &lt;sstream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<dfn>#include &lt;vector&gt;</dfn>

<var>static</var> <var>bool</var> port_is_open(<var>const</var> std::string&amp; address, <var>int</var> port)
{
    <var>return</var> (sf::SocketTCP().connect(address, port) == sf::Socket::Done);
}

<var>static</var> std::vector&lt;std::string&gt; split(<var>const</var> std::string&amp; string,
                                      <var>char</var> delimiter = <kbd>' '</kbd>,
                                      <var>bool</var> allow_empty = <var>false</var>)
{
    std::vector&lt;std::string&gt; tokens;
    std::stringstream sstream(string);
    std::string token;
    <var>while</var> (std::getline(sstream, token, delimiter)) {
        <var>if</var> (allow_empty || token.size() &gt; 0)
            tokens.push_back(token);
    }
    <var>return</var> tokens;
}

<var>static</var> <var>int</var> string_to_int(<var>const</var> std::string&amp; string)
{
    std::stringstream sstream(string);
    <var>int</var> i;
    sstream &gt;&gt; i;
    <var>return</var> i;
}

<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> <var>void</var> swap(T&amp; a, T&amp; b)
{
    T c = a;
    a = b;
    b = c;
}

<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> std::vector&lt;T&gt; range(T min, T max)
{
    <var>if</var> (min &gt; max)
        swap(min, max);
    <var>if</var> (min == max)
        <var>return</var> std::vector&lt;T&gt;(1, min);
    std::vector&lt;T&gt; values;
    <var>for</var> (; min &lt;= max; ++min)
        values.push_back(min);
    <var>return</var> values;
}

<var>static</var> std::vector&lt;<var>int</var>&gt; parse_ports_list(<var>const</var> std::string&amp; list)
{
    std::vector&lt;<var>int</var>&gt; ports;
    <var>for</var> (<var>const</var> std::string&amp; token : split(list, <kbd>','</kbd>)) {
        std::vector&lt;std::string&gt; strrange = split(token, <kbd>'-'</kbd>);
        <var>switch</var> (strrange.size()) {
            <var>case</var> 0: ports.push_back(string_to_int(token));       <var>break</var>;
            <var>case</var> 1: ports.push_back(string_to_int(strrange[0])); <var>break</var>;
            <var>case</var> 2:
            {
                <var>int</var> min = string_to_int(strrange[0]),
                    max = string_to_int(strrange[1]);
                <var>for</var> (<var>int</var> port : range(min, max))
                    ports.push_back(port);
                <var>break</var>;
            }
            <var>default</var>:
                <var>break</var>;
        }
    }
    <var>return</var> ports;
}

<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> T maximum(<var>const</var> std::vector&lt;T&gt;&amp; values)
{
    T max = values[0];
    <var>for</var> (T value : values) {
        <var>if</var> (value &gt; max)
            max = value;
    }
    <var>return</var> max;
}

<var>template</var> &lt;<var>typename</var> T&gt;
<var>static</var> size_t digits(T value)
{
    size_t count = (value &lt; 0) ? 1 : 0;
    <var>if</var> (value == 0)
        <var>return</var> 0;
    <var>while</var> (value) {
        value /= 10;
        ++count;
    };
    <var>return</var> count;
}

<var>int</var> main(<var>int</var> argc, <var>char</var>* argv[])
{
    std::string address;
    std::vector&lt;<var>int</var>&gt; ports;
    <var>if</var> (argc == 3) {
        address = argv[1];
        ports = parse_ports_list(std::string(argv[2]));
    } <var>else</var> {
        std::string port_list;
        std::cout &lt;&lt; <kbd>"Address: "</kbd> &lt;&lt; std::flush;
        std::getline(std::cin, address);
        std::cout &lt;&lt; <kbd>"Port: "</kbd> &lt;&lt; std::flush;
        std::getline(std::cin, port_list);
        ports = parse_ports_list(port_list);
    }
    std::cout &lt;&lt; <kbd>"Showing open ports on "</kbd> &lt;&lt; address &lt;&lt; <kbd>"...\n"</kbd>;
    size_t width = digits(maximum(ports));
    <var>for</var> (<var>int</var> port : ports) {
        <var>if</var> (port_is_open(address, port))
            std::cout &lt;&lt; <kbd>"Port "</kbd> &lt;&lt; std::setw(width) &lt;&lt; port &lt;&lt; <kbd>" : OPEN\n"</kbd>;
    }
    std::cout &lt;&lt; std::flush;
    <var>return</var> 0;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Feel free to use or modify all the above code for any purpose (disclaimer: I will not be liable for any evil performed using my code).<br>
<br>
Attached you can find the source of the original program that I wrote, which turned into the above code as I wrote the article. That program is distributed under the FreeBSD license.<br>
<br>
<h3>To-Do</h3>
<ul>
<li>Command-line options</li>
<li>Display possible running program (<a href="../../../en.wikipedia.org/wiki/list_of_tcp_and_udp_port_numbers">List of TCP and UDP port numbers</a>)</li>
</ul><p>Attachments:
	[<a href="cppscan.cpp">cppscan.cpp</a>]
	[<a href="cppscan.h">cppscan.h</a>]
	[<a href="main.cpp">main.cpp</a>]
</p>
</div></div><div id="CH_bb"></div><div id="CH_scoreapp"></div><script type="text/javascript">new Score('CH_scoreapp','../score.cgi','o2N36Up4');</script></div>
</div>
<div id="I_nav">
<div class="sect root">
<h3><b><a href="../../default.htm">C++</a></b></h3>
<ul>
<li class="folder info"><a href="../../info/default.htm">Information</a></li>
<li class="folder doc"><a href="../../doc/default.htm">Tutorials</a></li>
<li class="folder reference"><a href="../../reference/default.htm">Reference</a></li>
<li class="folder selected articles"><a href="../default.htm">Articles</a></li>
<li class="folder forum"><a href="../../forum/default.htm">Forum</a></li>
</ul>
</div>
<div class="sect">
<h3><b><a href="../default.htm">Articles</a></b></h3>
<ul>
<li><a href="../algorithms/default.htm">Algorithms</a></li><li><a href="../cpp11/default.htm">C++ 11</a></li><li><a href="../graphics/default.htm">Graphics and multimedia</a></li><li><a href="../howto/default.htm">How-To</a></li><li><a href="../language/default.htm">Language Features</a></li><li><a href="../linux/default.htm">Unix/Linux programming</a></li><li><a href="../sourcecode/default.htm">Source Code</a></li><li><a href="../standard_library/default.htm">Standard Library</a></li><li><a href="../tips/default.htm">Tips and Tricks</a></li><li><a href="../tools/default.htm">Tools and Libraries</a></li><li><a href="../visualcpp/default.htm">Visual C++</a></li><li><a href="../winapi/default.htm">Windows API</a></li></ul>
</div>
<div id="I_subnav"></div>
</div>
<div id="I_midclear"></div>
</div>
</div>
<div id="I_bottom">
<div id="I_footer">
	<a href="../../default.htm">Home page</a> | <a href="../../privacy.do.htm">Privacy policy</a><br>&copy; cplusplus.com, 2000-2014 - All rights reserved - <i>v3.1</i><br><a href="../../contact.doreferrerwww.cplusplus.com_252farticles_25~65.htm">Spotted an error? contact us</a>
</div>
</div>

<script type="text/javascript">
<!--
onSession(function(us) {
		document.getElementById('I_subnav').innerHTML=
			us.ok?
				'<div class="sect"><h3><b><a href="../../user/default.htm">'+us.user+'</a></b></h3><ul>'+
				'<li><a href="../myitems.cgi.htm">My items</a></li>'+
				(us.auth(32768)?'<li><a href="../adminitems.cgi.htm">Admin items</a></li>':'')+
				'</ul></div>'
			:'';
	}); onSession(function (us) {
		var el=document.getElementById('CH_bb'); el.innerHTML='';
		if ( (us.auth(32768)) || ((us.uniqid=='GEw0RXSz')&&(us.auth(128))) ) {
			el.appendChild(btn('Edit article','Edit this version of the article','edit','../edit.cgiao2n36up4.htm'));
	
			if (us.auth(32768)) {
				el.appendChild(btn('Delete article','Delete this article','delete','javascript:artdel()'));
			}
	
		}
	});
	function artdel() { if (confirm('WARNING: You are about to delete this page. Confirm?')) window.location='../delete.cgiao2n36up4'; }
	ready();
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-521783-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? '../../../httpsssl/default.htm' : '../../../www/default.htm') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//-->
</script>

</body>
</html>