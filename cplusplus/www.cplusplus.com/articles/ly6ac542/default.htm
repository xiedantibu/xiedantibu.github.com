<!DOCTYPE html><!-- saved from url=(0054)http://www.cplusplus.com/articles/ly6ac542/default.htm --><meta http-equiv="X-UA-Compatible" content="IE=Edge" />

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Borland C++ Sorting Algorithm - C++ Articles</title>
<link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico">
<link rel="stylesheet" type="text/css" href="../../v321/main.css">
<script src="../../v321/main.js" type="text/javascript"></script>
</head>
<body>
<div id="I_top">
<div id="I_header">
<div id="I_logo"><a href="../../default.htm" title="cplusplus.com"><div></div></a></div>
<div id="I_search">
<form id="search" action="/search.do" method="get">
Search: <input name="q" size="20" class="txt"> <input type="submit" value="Go" class="btn">
</form>
</div>
<div id="I_bar">
<ul>
<li><a href="../default.htm">Articles</a></li>
<li class="here">Borland C++ Sorting Algorithm</li>
</ul>
</div>
<div id="I_user" class="C_LoginBox"><span title="ajax"></span></div>
</div>
</div>
<div id="I_mid">
<div id="I_wrap">
<div id="I_minheight"></div>
<div id="I_main">
<div id="I_content">
<div class="C_art">
<div id="I_author">Published by <b><a href="../../user/analyzoh/default.htm" rel="author">analyzoh</a></b></div>
<div id="I_date">Jul 6, 2014 (last update: Jul 7, 2014)</div>
<h1>Borland C++ Sorting Algorithm</h1>
<div id="I_score">Score: 4.0/5 (12 votes)</div>
<div id="I_stars"><img src="../../ico/16star.png" width="16" height="16" alt="*"><img src="../../ico/16star.png" width="16" height="16" alt="*"><img src="../../ico/16star.png" width="16" height="16" alt="*"><img src="../../ico/16star.png" width="16" height="16" alt="*"><img src="../../ico/16star-empty.png" width="16" height="16" alt="*"></div>
<div id="I_content">
<b>INTRODUCTION</b><br>
<br>
Have you ever wondered about the software programs that sort large numbers of items? We take them for granted to do our everyday tasks on the computer, but what exactly makes them function? Many software packages have implemented their own algorithms for taking care of this job. I have developed my own approach for handling this important task and I will present a detailed explanation here of how it works. <br>
<br>
<b>AN OVERVIEW OF MY PROBLEM</b><br>
<br>
In 1996 I was working on an inventory system for a customer using procedural C programming to sort a large number of items - about 8,000 to 10,000. The sorting program I had at the time was something I created in the early 1990s and could only sort up to 1,500 items. This Borland C <a href="../../../www.analyzohiosoftware.com/alphabetizing_code_readout.php">alphabetizing code</a> is listed on my website.<br>
<br>
Back in the mid 1990s, most IBM PC based computers were running Intel 486, Intel Pentium, AMD K-5, etc. However, their capability and that of the hard disks at the time seemed like they had to struggle to handle a large capacity sorting task like the one my application required. I had to start with the basic <a href="../../../www.analyzohiosoftware.com/programming-article-archive-cleveland-ohio.html">programming</a> idea behind my procedural C sorting code from the early 1990s and somehow expand it so it could process larger data files. If I tried to design the new sorting program so it did most of the work on the mechanical hard disk that would have created a  new problem. Attempting to sort a large data file on a disk drive would have created a very big reduction in speed because of slowness of the mechanical moving parts of the hard disk. The customer would certainly object to the slower speed and I would have been sent back to the drawing board to start over with something more acceptable.<br>
<br>
Performing the sorting on the hard disk was obviously a road to nowhere with a large data file. The only other option I could think of was to do the bulk of the work in the memory. By concentrating the data manipulation in memory, I could escape the slower world of the mechanical disk drive and pick up much more speed. This was especially important at the time because of the less powerful processors of the day. Another compelling reason for shifting the work into memory was because doing much of the work on a disk that could potentially have any number of sector errors on it could create catastrophic problems. This would have thrown a wrench into the sorting process and created a corrupted output file. Of course this is also possible with concentrating the work in memory, but it’s less likely to occur.<br>
 <br>
<b>MOVING FORWARD</b><br>
 <br>
I will begin discussing the “nuts and bolts” of how my algorithm works shortly. This new and <a href="../../../www.analyzohiosoftware.com/alphabetizing_code_readout_improved.php">improved alphabetizing code</a> for sorting jobs was later adapted to Borland C++ and I have included pieces of the code along with diagrams to help illustrate the logic flow. Please note that some of the C++ variables are referred to as “non-persistent” variables, while the “top” and “bott” variables are called “persistent” variables. This is because “non-persistent” variables are completely reset to new values during the processing while “persistent” variables are incremented or decremented at various times, but never reset. Also, you will notice I refer to various data structures I use such as “grid”, “name”, and “stor” as conventional data structures. They are allocated within the boundaries of the 64K data segment as prescribed by the small memory model I used in the programming. This is to differentiate them from the far memory data structures “s”, “s1” and “s2”. This algorithm was performed on binary fixed width text files. I use these in my <a href="../../../www.analyzohiosoftware.com/application-development-cleveland-ohio.html">application development</a> because they are easy to work with. The algorithm can easily be adjusted to work with binary variable width (delimited) text files, also.<br>
<br>
<b>THE MAIN OBJECTIVE: LARGER SORTING CAPACITY</b><br>
<br>
Now that I had decided to focus most of the processing in the memory, I had to come up with a way to do this so it could allocate the capacity for a large number of items. In Borland C/C++, there were 6 memory models to choose from: tiny, small, medium, compact, large and huge. I always used the small memory model since it was the default and I just became accustomed to dealing with it since I started with C coding in 1990. In the small memory model, the code and data segments each have 64K of memory available. In order to sort large numbers of items, I would need a much larger space of memory than a 64K data segment that also had to hold a variety of other data structures.<br>
<br>
I decided to use the far side of the heap, or what is known as “far memory”. To set this up, I first included a necessary C++ header file for allocating far memory:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>
<cite>// alloc.h is needed for far memory data structures.</cite>
<dfn>#include &lt;alloc.h&gt;</dfn>
 </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Then I declared 3 far memory pointers like this near the beginning of the sorting code:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code>
<cite>// declare far memory pointers.</cite>
<var>unsigned</var> <var>long</var> <var>int</var> far *s;
<var>unsigned</var> <var>long</var> <var>int</var> far *s1;
<var>unsigned</var> <var>long</var> <var>int</var> far *s2;
</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
I allocated them like this to handle up to 16,000 items:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code>
<cite>// allocate far memory.</cite>
s = ( <var>unsigned</var> <var>long</var> <var>int</var> far * ) farmalloc(65000L);
s1 = ( <var>unsigned</var> <var>long</var> <var>int</var> far * ) farmalloc(65000L);
s2 = ( <var>unsigned</var> <var>long</var> <var>int</var> far * ) farmalloc(65000L);
 </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The reason I set up 3 far memory data structures is because all of them are needed to manipulate the data with the new sorting algorithm I created. This gave me the space to manipulate up to 16,000 items. I could have allocated for a larger number of data records, but this was more than enough to do the job at hand.<br>
<br>
<b>ASSIGNING A NUMERICAL WEIGHT TO EACH ITEM IN THE DATA FILE</b><br>
<br>
The processing starts with applying a mathematical formula to the first four characters of each item in the binary fixed width text file. Consider the following numerical succession of powers of “10”:<br>
<br>
10,000,000     1,000,000     100,000     10,000     1,000     100     10     1<br>
<br>
Next, remove the following powers of “10” in the above numerical succession:<br>
<br>
1,000,000<br>
10,000<br>
100<br>
10<br>
<br>
This is what is left with these powers of “10” in the updated numerical succession:<br>
<br>
10,000,000     100,000     1,000     1<br>
<br>
The ASCII codes of each character in a given item can range from 32 to 126. Each of these ASCII codes has been “mapped” to numerical values ranging from 0 to 94. The numerical values for each of the first four characters starting from the beginning in a given item will each be multiplied by the updated numerical succession in a left to right fashion.<br>
<br>
This is the math formula I use in the programming to assign numerical weights to each item:<br>
<br>
(10,000,000 X numerical value of character 1) + <br>
(100,000 X numerical value of character 2) + <br>
(1,000 X numerical value of character 3) + <br>
(1 X numerical value of character 4) <br>
<br>
This amount is equal to the numerical weight for this item. Consider the following example:<br>
<br>
"SMITHSON"<br>
<br>
"S" = Character 1<br>
"M" = Character 2<br>
"I" = Character 3<br>
"T" = Character 4<br>
"H" = Character 5<br>
"S" = Character 6<br>
"O" = Character 7<br>
"N" = Character 8<br>
<br>
ASCII code for Character 1: S  = 83 which corresponds to numerical value 51 per the algorithm.<br>
ASCII code for Character 2: M = 77 which corresponds to numerical value 45 per the algorithm.<br>
ASCII code for Character 3: I   = 73 which corresponds to numerical value 41 per the algorithm.<br>
ASCII code for Character 4: T  = 84 which corresponds to numerical value 52 per the algorithm.<br>
<br>
Now, let’s plug in the numerical values from this example to the math formula to yield the numerical weight for the above item:<br>
<br>
(10,000,000 X 51) + (100,000 X 45) + (1,000 X 41) + (1 X 52)  = 514,541,052<br>
<br>
This math formula is something I came up with that I believed would be a good way to assign a numerical weight to each item. Here is a partial piece of the code that performs this task in the program:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br></code></pre></td>
<td class="source"><pre><code>
.
.
.
.
.
<cite>// open the data file "job_part.txt" for initial processing.</cite>
infile.open(<kbd>"job_part.txt"</kbd>, ios::in | ios::binary);      
inn = infile.rdbuf();                                 

<cite>// initialize far memory data structure position variables.</cite>
<cite>// "top" is the first sequential item and “bott” is number</cite>
<cite>// of items less 1, or the last sequential item. "top" and</cite>
<cite>// "bott" are what i call persistent item markers in the far</cite>
<cite>// memory data structures. this is because they are never reset</cite>
<cite>// to their original values during the entire processing sequence.</cite>
<cite>// “top” is incremented and “bott” is decremented during processing</cite>
<cite>// to assist in facilitating the overall sorting.</cite>
top = 0;                  
bott = number_of_items - 1;       
<cite>// initialize the record counter variable, “aa”.      </cite>
aa = 0;                     

	<cite>// &lt;----- start of processing loop "a".</cite>

	<cite>// this will calculate the highest and lowest numerical weights</cite>
	<cite>// for all items.</cite>
	<var>do</var> {                      

		<cite>// &lt;----- start of processing loop "b".</cite>

		<cite>// this will generate numerical weights for the items. get a</cite>
		<cite>// character from the current file pointer position and prepare</cite>
		<cite>// for further processing.</cite>
		inn -&gt; seekpos(fileoffset, ios::in);
		first_four_numbers = 0;
		<var>do</var> {                      
		<cite>// convert the character to uppercase for subsequent comparison.</cite>
		kh = infile.readByte();      
		khchar[0] = kh;             
		strupr(khchar);           
		kh = khchar[0];
		<cite>// assign numerical value range of 0 to 94 to variable “var1”</cite>
		<cite>// that i have mapped to the ascii character code range of 32 to 126.</cite>
		<var>if</var>( kh &lt;= 32 ) var1 = 0;
		<var>if</var>( kh == 33 ) var1 = 1;
		<var>if</var>( kh == 34 ) var1 = 2;
		<var>if</var>( kh == 35 ) var1 = 3;
		<var>if</var>( kh == 36 ) var1 = 4;
		<var>if</var>( kh == 37 ) var1 = 5;
		<var>if</var>( kh == 38 ) var1 = 6;		.
.
.
.
.
		<var>if</var>( kh == 119 ) var1 = 87;
		<var>if</var>( kh == 120 ) var1 = 88;
		<var>if</var>( kh == 121 ) var1 = 89;
		<var>if</var>( kh == 122 ) var1 = 90;
		<var>if</var>( kh == 123 ) var1 = 91;
		<var>if</var>( kh == 124 ) var1 = 92;
		<var>if</var>( kh == 125 ) var1 = 93;
		<var>if</var>( kh == 126 ) var1 = 94;
			<cite>// multiply the numeric variable "var1" for first character</cite>
			<cite>// of item by 10,000,000 and add to total for this item in</cite>
			<cite>// far memory data structure "s".</cite>
			<var>if</var>( first_four_numbers == 0 ) *(s+aa) = *(s+aa) + ( var1 * 10000000 );    
				<cite>// multiply the numeric variable "var1" for second character</cite>
				<cite>// of item by 100,000 and add to total for this item in far</cite>
				<cite>// memory data structure "s".</cite>
				<var>if</var>( first_four_numbers == 1 ) *(s+aa) = *(s+aa) + ( var1 * 100000 );      
					<cite>// multiply the numeric variable "var1" for third character</cite>
					<cite>// of item by 1,000 and add to total for this item in far</cite>
					<cite>// memory data structure "s".</cite>
					<var>if</var>( first_four_numbers == 2 ) *(s+aa) = *(s+aa) + ( var1 * 1000 );        
						<cite>// multiply the numeric variable "var1" for fourth character</cite>
						<cite>// of item by 1 and add to total for this item in far memory</cite>
						<cite>// data structure "s".</cite>
						<var>if</var>( first_four_numbers == 3 ) *(s+aa) = *(s+aa) + ( var1 * 1 );           
                                                     
			<cite>// ( first item character numerical value X 10,000,000 ) + </cite>
			<cite>// ( second item character numerical value X 100,000 ) + </cite>
			<cite>// ( third item character numerical value X 1,000 ) + </cite>
			<cite>// ( fourth item character numerical value X 1 ) = numerical </cite>
			<cite>// weighted value for the item. this accumulated numerical</cite>
			<cite>// value is stored in far memory data structure "s" for the</cite>
			<cite>// corresponding item's sequential position in the data file.</cite>

					<cite>// the first 4 characters of each item are subjected to the</cite>
					<cite>// above math formula. they are given a numerical weighting,</cite>
					<cite>// which will later be used to segment the actual sorting process</cite>
					<cite>// into "top1" and "bott1" processing regions. in other words,</cite>
					<cite>// the sorting process is performed in a compartmentalized fashion.</cite>

		<cite>// &lt;----- end of processing loop "b".</cite>

		first_four_numbers++;
		} <var>while</var>( first_four_numbers &lt; 4 );                                      

<cite>// as we are moving from the top to the bottom of the data</cite>
<cite>// file, keep track of the lowest primary and highest primary</cite>
<cite>// accumulated numerical values as they are stored in far memory</cite>
<cite>// data structure "s". the value extremes (highest and lowest)</cite>
<cite>// are assigned to the primary high “up1” and primary low “low1”</cite>
<cite>// variables, respectively.                                                     </cite>
<var>if</var>( aa == 0 ) {                                        
low1 = *(s+aa);                                     
up1 = *(s+aa);                                   
}
<var>if</var>( *(s+aa) &lt; low1 ) low1 = *(s+aa);               
<var>if</var>( *(s+aa) &gt; up1 ) up1 = *(s+aa);                 
                                                     
	<cite>// move to next record of the data file "job_part.txt". the constant</cite>
	<cite>// record length in this case is “RECORDLENGTH” and fixed field width (SDF format).                                                 </cite>
	aa++;
	fileoffset = fileoffset + RECORDLENGTH;                      

	<cite>// &lt;----- end of processing loop "a".</cite>

	} <var>while</var>( aa &lt; number_of_items );

infile.close();                                     
.
.
.
.
.
</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The lowest and highest numerical weights are now known after we have applied this math formula to all the items in the data file. All numerical weights will be stored in the far memory data structure “s” in positions that correspond to their sequential positions in the unsorted data file (See Figure 1).<br>
<br>
<br><IMG SRC="first_one.jpg" height=100% width=100% alt=""><br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br></code></pre></td>
<td class="source"><pre><code>
.
.
.
.
.
<cite>// if the lowest primary “low1” and highest primary “up1” variables are not equal,</cite>
<cite>// meaning there are records to be sorted, then proceed with processing.</cite>
<var>if</var> ( low1 != up1 ) {      

	<cite>// initialize high "main" processing loop exit variable "qqq" to stay within</cite>
	<cite>// the processing loop.                            </cite>
	qqq = 0;                    
	<cite>// initialize low "main" processing loop exit variable "sss" to stay within</cite>
	<cite>// the processing loop.</cite>
	sss = 0;                    

		<cite>// &lt;----- start of “main” processing loop.</cite>

		<cite>// the "main" processing loop will redefine "top1" and "bott1" pairs of</cite>
		<cite>// processing regions until all items are sorted.</cite>
		<var>do</var> {                      
                            
		<cite>// assign primary high variable "up1" to secondary low variable "low2".</cite>
		low2 = up1;               
		<cite>// assign primary low variable "low1" to secondary high variable "up2".</cite>
		up2 = low1;               

		<cite>// the loop that follows will set boundaries and numerical values for</cite>
		<cite>// processing regions "top1" and "bott1". each of these processing regions</cite>
		<cite>// can handle up to 150 items with the same numerical weighting as calculated</cite>
		<cite>// above on the first 4 characters of the item. i need to mention that there</cite>
		<cite>// is a highly unlikely possibility that the algorithm could malfunction if a</cite>
		<cite>// specific numerical weight that has been assigned to a "top1" or "bott1"</cite>
		<cite>// processing region exceeds 150 items. this is because it would exceed the row</cite>
		<cite>// depth of the 2 dimensional “grid” conventional data structure which is heavily</cite>
		<cite>// used for sorting and insertion operations in the "top1" and "bott1" processing</cite>
		<cite>// regions. i have used this algorithm in many of my programs and have never seen</cite>
		<cite>// this happen. </cite>

		<cite>// initialize item loop counting variable "ii" to 0.</cite>
		ii = 0;                     
		<cite>// initialize upper processing region "top1" non-persistent processing region.</cite>
		top1 = 0;                   
		<cite>// initialize lower processing region "bott1" non-persistent processing region.</cite>
		bott1 = 0;                  
		<cite>// initialize the start of upper processing region "start" non-persistent item</cite>
		<cite>// marker with "top" persistent item marker.</cite>
		start = top;                
		<cite>// initialize the start of lower processing region "finish" non-persistent item</cite>
		<cite>// marker with "bott" persistent item marker.                            </cite>
		finish = bott;              

			<cite>// &lt;----- start of processing loop "c".                            </cite>

			<var>do</var> {                      

				<cite>// if the numerically weighted value for the given item in far memory data</cite>
				<cite>// structure “s” for index “ii” is equal to the lowest primary variable</cite>
				<cite>// “low1” and the high “main” processing loop exit variable “qqq” is set to</cite>
				<cite>// stay within the “main” processing loop, then assign the sequential file</cite>
				<cite>// position value for the given item “ii” to far memory data structure “s1”</cite>
				<cite>// in the array position denoted by the “top” persistent item marker.</cite>
				<var>if</var>( *(s+ii) == low1 &amp;&amp; qqq == 0 ) {     
				*(s1+top) = ii;                      
				<cite>// next, increment the “top” persistent item marker and “top1” non-persistent</cite>
				<cite>// item marker by 1 each.</cite>
				top++;                               
				top1++;                              
				}

				<cite>// if the numerically weighted value for the given item in far memory data</cite>
				<cite>// structure “s” for index “ii” is equal to the highest primary variable “up1”</cite>
				<cite>// and the low “main” processing loop exit variable “sss” is set to stay within</cite>
				<cite>// the processing loop, then assign the sequential numerical file position value</cite>
				<cite>// for the given item “ii” to far memory data structure “s1” in the array position</cite>
				<cite>// denoted by “bott” persistent item marker.</cite>
				<var>if</var>( *(s+ii) == up1 &amp;&amp; sss == 0 ) {    
				*(s1+bott) = ii;                     
				<cite>// next, decrement the “bott” persistent item marker and increment “bott1” non-persistent</cite>
				<cite>// item marker by 1 each.                                       </cite>
				bott--;                                
				bott1++;                              
				}

				<cite>// if the numerically weighted value for the given item in far memory data structure “s”</cite>
				<cite>// is greater than the lowest primary variable “low1” and is less than the lowest secondary</cite>
				<cite>// variable “low2”, then assign numerically weighted value for the given item for index “ii”</cite>
				<cite>// in far memory data structure “s” to the lowest secondary variable “low2”.</cite>
				<var>if</var>( *(s+ii) &gt; low1 &amp;&amp; *(s+ii) &lt; low2 ) low2 = *(s+ii);    
                                                                
				<cite>// if the numerically weighted value for the given item in far memory data structure “s” is</cite>
				<cite>// less than the highest primary variable “up1” and is greater than the highest secondary</cite>
				<cite>// variable “up2”, then assign numerically weighted value for the given item for index “ii”</cite>
				<cite>// in far memory data structure “s” to the highest secondary variable “up2”.                                                               </cite>
				<var>if</var>( *(s+ii) &lt; up1 &amp;&amp; *(s+ii) &gt; up2 ) up2 = *(s+ii);      
                                                                
			<cite>// increment item counting variable "ii" by 1 and loop sequentially through the data file until</cite>
			<cite>// the item counting variable is at the end. this looping routine will set the records of the</cite>
			<cite>// same numerically weighted value to be processed for sorting in processing region "top1" and</cite>
			<cite>// the same for processing region "bott1". the “start” non-persistent item marker is the beginning</cite>
			<cite>// of the “top1” processing region and “start+top1” is the end. the “finish” non-persistent item</cite>
			<cite>// marker is the end of the “bott1” processing region and “finish-bott1+1” is the beginning. </cite>

			<cite>// &lt;----- end of processing loop "c".                                                                </cite>

			ii++;                    
			} <var>while</var>( ii &lt; number_of_items );           
                           
					<cite>// first, set the variable “r” equal to 0. if the secondary low variable “low2” and the</cite>
					<cite>// secondary high variable “up2” are equal and the low "main" processing loop exit variable</cite>
					<cite>// “sss” is set to stay within the "main" processing loop, then set the low "main" processing</cite>
					<cite>// loop exit variable “sss” to attempt to exit the "main" processing loop. also, set the</cite>
					<cite>// variable “r” equal to 1 so the very next logic structure will not be evaluated.</cite>
					r = 0;
					<var>if</var>( low2 == up2 &amp;&amp; sss == 0 ) {     
					sss = 1;                            
					r = 1;
					}

					<cite>// if the variable “r” is still set to 0, then evaluate the next logic structure which is</cite>
					<cite>// described as follows. if the secondary low variable “low2” and the secondary high</cite>
					<cite>// variable “up2” are equal and the low "main" processing loop exit variable “sss” is set</cite>
					<cite>// to attempt to exit the "main" processing loop, then set the high "main" processing loop</cite>
					<cite>// exit variable “qqq” to attempt to exit the "main" processing loop.</cite>
					<var>if</var>( low2 == up2 &amp;&amp; r == 0 &amp;&amp; sss == 1 ) qqq = 1;        
                                                      
					<cite>// if the secondary low numerically weighted variable “low2” is greater than the secondary</cite>
					<cite>// high numerically weighted variable “up2”, then set the low "main" processing loop exit</cite>
					<cite>// variable “sss” and the high "main" processing loop exit variable “qqq” to both exit the</cite>
					<cite>// "main" processing loop, which will cease the redefinition of successive “top1” and “bott1”</cite>
					<cite>// processing regions.</cite>
					<var>if</var>( low2 &gt; up2 ) {             
					qqq = 1;                       
					sss = 1;
					}

					<cite>// next, assign secondary low weighted variable “low2” to primary low weighted variable “low1”.</cite>
					low1 = low2;                 
					<cite>// next, assign secondary high weighted variable “up2” to primary high weighted variable “up1”.</cite>
					up1 = up2;                   
					.
					.
					.
					.
					.
</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In the above patch of code, the first thing that occurs is to see whether or not the lowest and highest numerical weights are equal. This compares the lowest primary variable “low1” to the highest primary variable “up1”. If they are equal, the start of processing will be aborted because all items will have the same numerical weight. This means the first 4 characters of all items are the same. This would be highly unusual because they would already be nearly sorted to begin with and the probability of ever encountering a data file like this would be remote. In the end, the original data file to be sorted would be left intact and not be reconstructed at the end. If they are unequal, the lowest primary variable “low1” and the highest primary variable “up1” would represent two different sets of numerically weighted items and therefore processing would continue with the commencement of the “main” processing loop.<br>
<br>
<b>A TALE OF TWO FAR MEMORY PROCESSING REGIONS: “TOP1” AND “BOTT1” </b><br>
<br>
The program cycles around a “do-while loop” which I call the “main” processing loop. I use 2 regions of far memory to facilitate the sorting process, which I call the “top1” and “bott1” processing regions. Each of these will be repeatedly redefined with each loop through the “main” processing loop. This is the “segmented mechanism” which drives the sorting process.<br>
<br>
Both of these processing regions actually begin as numerical variables. They later evolve into processing regions. First, they are both initialized to 0. Then “top1” is incremented by 1 for each item in the far memory data structure “s” that corresponds to the lowest primary variable, “low1” (lowest current numerical weight). Next, “bott1” is incremented by 1 for each item in the far memory data structure “s” that corresponds to the highest primary variable, “up1” (highest current numerical weight). This is done in the above code. Also, the “main” processing loop exit variables “qqq” and “sss” cannot be set to exit the “main” processing loop while both processing regions need to be redefined to process unsorted items. In other words, “qqq” must be set to 0 for “top1” to include the lowest current numerical weight in its processing region that is being defined. And “sss” must be set to 0 for “bott1” to include the highest current numerical weight in its processing region, which is also being defined.<br>
<br>
One other thing to notice in the previous code are 2 markers I use for the items denoted by “start” and “finish”. “start” is assigned the value in “top”, and “finish” is assigned the value in “bott”. “start” is a “non-persistent” item marker used to denote the item count or depth of the “top1” processing region. “finish” is a “non-persistent” item marker used to denote the item count or depth of the “bott1” processing region. Both “top” and “bott” are “persistent” item markers that are incremented along with “top1” and “bott1”. (See Figures 7 and 8 to see a visual representation of the “top1” and “bott1” processing regions.)<br>
<br>
<br><IMG SRC="fifth_one.jpg" height=100% width=100% alt=""><br>
<br>
After the redefinition process is completed, the “top1” processing region will encompass items corresponding to the lowest current numerical weight. The same is true for the “bott1” processing region, but with a numerical weight that corresponds to the highest current numerical weight. The algorithm will use both processing regions to facilitate the actual sorting process, the specifics of which I will not get into with this article. To view that, you can refer to the “improved alphabetizing code” hyperlink near the beginning of the article. After the sorting has been performed, the program will loop around the “main” processing loop and proceed to redefine new pairs of “top1” and “bott1” processing regions. (See Figure 2).<br>
<br>
<br><IMG SRC="second_one.jpg" height=100% width=100% alt=""><br>
<br>
Both processing regions will approach each other in spatial proximity as they move toward the center of the far memory data structure “s” from being redefined with each pass through the “main” processing loop. Each new “top1” processing region will have a higher numerical weight than its predecessor “top1” region. Each new “bott1” processing region will have a lower numerical weight than its predecessor “bott1” region. Please refer to figures 3, 4, 5, and 6 for a visual illustration of the progression of the algorithm as successive “top1” and “bott1” processing regions are redefined with each pass through the “main” processing loop.<br>
<br>
<br><IMG SRC="third_one.jpg" height=100% width=100% alt=""><br>
<br>
<br><IMG SRC="fourth_one.jpg" height=100% width=100% alt=""><br>
<br>
Notice what happens in Figure 6 after the processing in successive “top1” and “bott1” processing regions reaches the middle of far memory in the far memory data structure “s”. The “top1” processing region with the least lowest numerical weight is adjacent to the “bott1” processing region with the least highest numerical weight. The processing will cease at this point because there will be no more items left to sort. The “main” processing loop will then be exited and the new sorted array of item positions stored in far memory data structure “s1” will be written to a new data file. (See Figures 9 and 10).<br>
<br>
<br><IMG SRC="sixth_one.jpg" height=100% width=100% alt=""><br>
<br>
<br><IMG SRC="seventh_one.jpg" height=100% width=100% alt=""><br>
<br>
Here, I want to talk about ways the “main” processing loop could be exited before the data is written back to a newly sorted data file. As the processing draws to a close in the middle of the far memory data structure “s”, it will not necessarily end with an even pair of final “top1” and “bott1” processing regions. It can also near completion with either of the “top1” or “bott1” processing regions having its “main” processing loop exit variable set to attempt to exit the “main” processing loop. To be more specific, the “top1” processing region could have its “main” loop exit variable “qqq” set to 1, which means there are no more “top1” regions to be redefined. The “bott1” processing region could have its “main” loop exit variable “sss” set to 0, meaning there is another “bott1” processing region to be redefined and sorted. The opposite of this can also occur.<br>
<br>
<b>AN ANALOGY THAT MAY HELP CLARIFY THE LOGIC FLOW</b><br>
<br>
Knowing this narrative may be overwhelming for some readers, I would like to take a page from American history that may be helpful in creating a better understanding of how my algorithm works. <br>
<br>
During the latter part of the 19th century, the United States turned its attention to nation building. Connecting the vast expanse of North America by way of a coast-to-coast railroad became a national priority. This was the start of America’s first Transcontinental Railroad.<br>
<br>
Two railroad companies, the Union Pacific and the Central Pacific, spearheaded this ambitious and daunting task. The Central Pacific began building its railway eastward from Sacramento, California, while the Union Pacific began construction work heading westward from Omaha, Nebraska.<br>
<br>
Both crews in the east and west worked relentlessly for seven years. On April 28, 1868 the Union Pacific’s construction gang of Chinese and Irish workers laid ten miles of railroad track in a single day as a result of a $10,000 bet that it could actually be done. On May 10, 1869 the construction was completed at Promontory Point in the Utah territory. The Union Pacific’s No. 119 engine and the Central Pacific’s No. 60 engine, Jupiter, were drawn up face-to-face separated by the width of a single railroad tie. At the Golden Spike ceremony, three spikes were driven in to connect the two railways: gold, silver and a composite spike made from gold, silver and iron. Travel time between the east and west coasts of the United States was reduced from 4 to 6 months to only 6 days by railroad! <br>
<br>
Now, the progression of my algorithm is quite similar to the construction of America’s first Transcontinental Railroad when you take a moment to really think about it. As the algorithm moves along, it begins to resemble two work crews gradually progressing towards a conclusion in the middle of the allocated far memory space, which is like a long stretch of terrain awaiting the arrival of “sorting construction labor”, so to speak. The “top1” and “bott1” processing regions are like “two construction gangs” that commence “sorting work” that begins at opposite ends of the allocated memory space. They each work hard to sort items of the same numerical weight as previously described, while constantaly moving closer and closer to one another. After the program loops around the “main” processing loop and new “top1” and “bott1” processing regions have been defined, the process repeats itself. Finally, The “Golden Spike Ceremony” occurs when the “top1” and “bott1” processing regions are adjacent to one another somewhere near the middle of the allocated far memory segment -  Promontory Point in the Utah territory, if I may use that to hopefully foster a better understanding of my algorithm.<br>
<br>
<b>A POTENTIAL PROBLEM AND A REMEDY</b><br>
<br>
Here, I would like to expand on a potential problem with my algorithm and a recommended solution that should take care of it. The 2 dimensional “grid” conventional data structure is used extensively to manipulate items in the “top1” and “bott1” processing regions. It is designed to hold up to 150 items of the same numerical weight. You need to be conscious about how much row depth you give the 2 dimensional “grid” conventional data structure so it and other conventional data structures taken together don’t breach the 64K data segment of the small memory model that is used. The problem arises if there are more than 150 items in a “top1” or “bott1” processing region. The algorithm won’t abort or malfunction, but rather it will include only the first 150 items in a processing region. I never really tried to address this potential snafu, because it is highly unlikely to occur in the first place. There would have to be more than 150 “Smiths” or “Joneses” to trigger the glitch. This could potentially happen in a voter registration verification data file that could include a large number of same last names.<br>
<br>
A good way to correct this is to declare a fourth far memory data structure of the same size as each of the first 3. It would replace and perform the job of the 2 dimensional “grid” conventional data structure, yet it would always be large enough to hold all the items for a particular numerical weight. This is because it would be allocated to hold as many items as are in the entire data file.<br>
<br>
<b>JUST SAY “NO” TO REDUNDANT, SPEED ROBBING CODE</b><br>
	<br>
Many of you may be wondering by now about the speed of the algorithm. I tested it with a binary fixed record width text file containing 10,959 part numbers. On a Gateway Pentium 4 tower CPU using an old 6 GB Quantum Bigfoot hard drive the processing took a little over 3 seconds. When it was run on a Dell M5030 laptop with an AMD V160 Processor at 2.4 GHz it took about 1 second. There are some areas in the “do-while” loop processing that could be redesigned or eliminated that should further increase the processing speed since less work is required to achieve the same result. After I finished this in 1996 it seemed to work in a reasonable amount of time so I didn’t go back and try to optimize it some more. Here I will elaborate with some selected areas in the code that could be improved to yield more processing speed.<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br></code></pre></td>
<td class="source"><pre><code>
	.
	.
	.
	.
	.	
		<cite>// convert the character to uppercase for subsequent comparison.</cite>
		kh = infile.readByte();      
		khchar[0] = kh;             
		strupr(khchar);           
		kh = khchar[0];
		<cite>// assign numerical value range of 0 to 94 to variable “var1”</cite>
		<cite>// that i have mapped to the ascii character code range of 32 to 126.</cite>
		<var>if</var>( kh &lt;= 32 ) var1 = 0;
		<var>if</var>( kh == 33 ) var1 = 1;
		<var>if</var>( kh == 34 ) var1 = 2;
		<var>if</var>( kh == 35 ) var1 = 3;
		<var>if</var>( kh == 36 ) var1 = 4;
		<var>if</var>( kh == 37 ) var1 = 5;
		<var>if</var>( kh == 38 ) var1 = 6;
		.
.
.
.
.
		<var>if</var>( kh == 119 ) var1 = 87;
		<var>if</var>( kh == 120 ) var1 = 88;
		<var>if</var>( kh == 121 ) var1 = 89;
		<var>if</var>( kh == 122 ) var1 = 90;
		<var>if</var>( kh == 123 ) var1 = 91;
		<var>if</var>( kh == 124 ) var1 = 92;
		<var>if</var>( kh == 125 ) var1 = 93;
		<var>if</var>( kh == 126 ) var1 = 94;
	.
	.
	.
	.
	.
</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This block of code that tests for ASCII characters 32 through 126 could be replaced with the C++ function, “atoi()”. It would eliminate much of the repetitive conditional “if-then” logic structure comparisons and convert the character to an integer. This new integer value could then be used in the math formula that computes numerical weights for each item. Here is another place for adding some speed:<br>
	<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br></code></pre></td>
<td class="source"><pre><code>
	.
	.
	.
	.
	.
		<cite>// set processing loop “2” counter variable “ii” to the non-persistent "start" item</cite>
		<cite>// marker denoting the beginning of the "top1" processing region.</cite>
		ii = start;           
       
		<cite>// &lt;----- start of processing loop "2".                               </cite>

		<var>do</var> {                       

		<cite>// retrieve and calculate file stream position offset of the item for processing loop</cite>
		<cite>// “2” counter "ii" in the far memory data structure “s1”.</cite>
		far_memory_contents_2 = *(s1+ii);               
		far_memory_contents_2 = far_memory_contents_2 * RECORDLENGTH;    
                                 
		<cite>// use calculated file stream position offset "far_memory_contents_2" to retrieve all</cite>
		<cite>// characters of the item except the first 4 characters into the "name" conventional</cite>
		<cite>// data structure. compare this to the 2 dimensional "grid" conventional data structure</cite>
		<cite>// set at lower index counter "lowx". if they are equal and high processing loop “1”</cite>
		<cite>// exit variable "qqqx" is set to stay within processing loop "1", then assign the</cite>
		<cite>// sequential item position in far memory data structure "s1" for	 processing loop “2”</cite>
		<cite>// counter variable “ii” to far memory data structure "s2" for non-persistent index</cite>
		<cite>// marker "topx". next, increment non-persistent index marker "topx" by 1.</cite>
		r = 0;
		inn -&gt; seekpos(far_memory_contents_2 + 4, ios::in);                          
		<var>for</var>(v = 0; v &lt; FIELDLENGTH - 4; v++) name[v] = infile.readByte();  
		strupr(name);                                             
                                                            
		<var>for</var>(v = 0; v &lt; FIELDLENGTH - 4; v++) {                          
		<var>if</var>( name[v] != grid[v][lowx] ) r = 1;                           
		}                                                         
                                                            
		<var>if</var>( r == 0 &amp;&amp; qqqx == 0 ) {                                 
		*(s2+topx) = *(s1+ii);                                    
		topx++;
		}

		<cite>// retrieve and calculate file stream position offset of the item for processing loop</cite>
		<cite>// “2” counter "ii" in the far memory data structure “s1”.</cite>
		far_memory_contents_2 = *(s1+ii);              
		far_memory_contents_2 = far_memory_contents_2 * RECORDLENGTH;   
                                
		<cite>// use calculated file stream position offset "far_memory_contents_2" to retrieve all</cite>
		<cite>// characters of the item except the first 4 characters into the "name" conventional</cite>
		<cite>// data structure. compare this to the 2 dimensional "grid" conventional data structure</cite>
		<cite>// set at higher index counter "upx". if they are equal and low processing loop “1” exit</cite>
		<cite>// variable "sssx" is set to stay within processing loop "1", then assign the sequential</cite>
		<cite>// item position in far memory data structure "s1" for processing loop “2” counter variable</cite>
		<cite>// “ii” to far memory data structure "s2" for non-persistent index marker "bottx". next,</cite>
		<cite>// decrement non-persistent index marker "bottx" by 1.</cite>
		r = 0;
		inn -&gt; seekpos(far_memory_contents_2 + 4, ios::in);                          
		<var>for</var>(v = 0; v &lt; FIELDLENGTH - 4; v++) name[v] = infile.readByte();  
		strupr(name);                                             
                                                            
		<var>for</var>(v = 0; v &lt; FIELDLENGTH - 4; v++) {                          
		<var>if</var>( name[v] != grid[v][upx] ) r = 1;                            
		}                                                         
                                                            
		<var>if</var>( r == 0 &amp;&amp; sssx == 0 ) {                                 
		*(s2+bottx) = *(s1+ii);                                   
		bottx--;
		}

		<cite>// increment processing loop “2” counter variable “ii” by 1. processing loop “2” counter</cite>
		<cite>// variable “ii” cycles through the non-persistent "start+top1" depth for the "top1"</cite>
		<cite>// processing region.</cite>
		ii++;                              

		<cite>// &lt;----- end of processing loop "2".</cite>

		} <var>while</var>( ii &lt; start + top1 );            	.
	.
	.
	,
	.
</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In the “top1” and “bott1” processing sections of the code, there is a patch of code enclosed by processing loop “2”. There are two places where the “far_memory_contents_2” file stream position offset is calculated twice. It is then used to retrieve data into the “name” conventional data structure for comparison operations in two different rows in the 2 dimensional “grid” conventional data structure. It only needs to be calculated once to achieve the same result. In fact, the “name” conventional data structure only needs to retrieve the data once with each processing loop “2” loop instead of twice.<br>
	<br>
<b>CONCLUSION</b><br>
<br>
I have used this sorting algorithm in many C++ applications, typically for sorting part numbers or customer names that are to be previewed as reports. It has proven itself to be reliable as well as fast. I have also adapted it for sorting numbers and dates. If you would like to learn more about my <a href="../../../www.analyzohiosoftware.com/developer-skills-cleveland-ohio.html">developer skills</a>, then please visit my <a href="../../../www.analyzohiosoftware.com/index.html">software developer</a> website. Additionally, be sure to check out my <a  href="../../../www.analyzohiosoftware.com/computer-repair-cleveland-ohio.html">computer repair</a> services and my <a href="../../../www.analyzohiosoftware.com/tektip-archive-cleveland-ohio.html">"fix my computer"</a> technical tips.<br>
 <br>
<br>
References:<br>
<br>
http://www (dot) accelerationwatch (dot) com/promontorypoint (dot) html<br>
<br>
http://en (dot) wikipedia (dot) org/wiki/Promontory,_Utah<br>
<br>
http://www (dot) history (dot) com/topics/transcontinental-railroad<br>
</div></div><div id="CH_bb"></div><div id="CH_scoreapp"></div><script type="text/javascript">new Score('CH_scoreapp','../score.cgi','Ly6AC542');</script></div>
</div>
<div id="I_nav">
<div class="sect root">
<h3><b><a href="../../default.htm">C++</a></b></h3>
<ul>
<li class="folder info"><a href="../../info/default.htm">Information</a></li>
<li class="folder doc"><a href="../../doc/default.htm">Tutorials</a></li>
<li class="folder reference"><a href="../../reference/default.htm">Reference</a></li>
<li class="folder selected articles"><a href="../default.htm">Articles</a></li>
<li class="folder forum"><a href="../../forum/default.htm">Forum</a></li>
</ul>
</div>
<div class="sect">
<h3><b><a href="../default.htm">Articles</a></b></h3>
<ul>
<li><a href="../algorithms/default.htm">Algorithms</a></li><li><a href="../cpp11/default.htm">C++ 11</a></li><li><a href="../graphics/default.htm">Graphics and multimedia</a></li><li><a href="../howto/default.htm">How-To</a></li><li><a href="../language/default.htm">Language Features</a></li><li><a href="../linux/default.htm">Unix/Linux programming</a></li><li><a href="../sourcecode/default.htm">Source Code</a></li><li><a href="../standard_library/default.htm">Standard Library</a></li><li><a href="../tips/default.htm">Tips and Tricks</a></li><li><a href="../tools/default.htm">Tools and Libraries</a></li><li><a href="../visualcpp/default.htm">Visual C++</a></li><li><a href="../winapi/default.htm">Windows API</a></li></ul>
</div>
<div id="I_subnav"></div>
</div>
<div id="I_midclear"></div>
</div>
</div>
<div id="I_bottom">
<div id="I_footer">
	<a href="../../default.htm">Home page</a> | <a href="../../privacy.do.htm">Privacy policy</a><br>&copy; cplusplus.com, 2000-2014 - All rights reserved - <i>v3.1</i><br><a href="../../contact.doreferrerwww.cplusplus.com_252farticles_25~41.htm">Spotted an error? contact us</a>
</div>
</div>

<script type="text/javascript">
<!--
onSession(function(us) {
		document.getElementById('I_subnav').innerHTML=
			us.ok?
				'<div class="sect"><h3><b><a href="../../user/default.htm">'+us.user+'</a></b></h3><ul>'+
				'<li><a href="../myitems.cgi.htm">My items</a></li>'+
				(us.auth(32768)?'<li><a href="../adminitems.cgi.htm">Admin items</a></li>':'')+
				'</ul></div>'
			:'';
	}); onSession(function (us) {
		var el=document.getElementById('CH_bb'); el.innerHTML='';
		if ( (us.auth(32768)) || ((us.uniqid=='yvkjE3v7')&&(us.auth(128))) ) {
			el.appendChild(btn('Edit article','Edit this version of the article','edit','../edit.cgialy6ac542.htm'));
	
			if (us.auth(32768)) {
				el.appendChild(btn('Delete article','Delete this article','delete','javascript:artdel()'));
			}
	
		}
	});
	function artdel() { if (confirm('WARNING: You are about to delete this page. Confirm?')) window.location='../delete.cgialy6ac542'; }
	ready();
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-521783-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? '../../../httpsssl/default.htm' : '../../../www/default.htm') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//-->
</script>

</body>
</html>