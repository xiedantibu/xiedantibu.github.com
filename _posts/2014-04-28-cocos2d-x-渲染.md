---
layout: post
title: "cocos2d-x 渲染"
category : cocos2d-x
tagline: "转载本站文章请注明作者和出处"
tags : [cocos2d-x]
---
{% include JB/setup %}

本文主要针对于2.2.3 cocos2d-x渲染做一分析，TestCpp ios项目启动,⾸先运行的当然就是main.m这个类了啊    
    
    main(int argc, char *argv[]) {
    
        NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    	int retVal = UIApplicationMain(argc, argv, nil, @"AppController");
    	[pool release];
    	return retVal;
       
    }

现在跟进到AppController,这里的AppController并不是cocos2d-x中的AppController，而是ios项目中的，找到`- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions`方法,在该方法中有这么一句话`cocos2d::CCApplication::sharedApplication()->run()`，好了咱得去找CCApplication了。  
####CCApplication run方法中  

	int CCApplication::run()
	{
    	if (applicationDidFinishLaunching()) 
    	{
        	[[CCDirectorCaller sharedDirectorCaller] startMainLoop];//启动了线程
   	 	}
    	return 0;
	}  
####跟进到startMainLoop中

	[displayLink invalidate];
    displayLink = nil;
    //实例化CADisplayLink
    displayLink = [NSClassFromString(@"CADisplayLink") displayLinkWithTarget:self  selector:@selector(doCaller:)];//回调doCaller:
    [displayLink setFrameInterval: self.interval];
    [displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];

CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。CADisplayLink以特定模式注册到runloop后，每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的selector就会被调用一次。  

在doCaller:这个回调方法中，也就这么一句话`cocos2d::CCDirector::sharedDirector()->mainLoop()`,终于找到了党，CCDirector熟悉了吧。话说CCDirector没有直接实现mainLoop()这个方法，而是请他小弟CCDisplayLinkDirector来实现的。  
####CCDisplayLinkDirector的mainLoop()  
	if (m_bPurgeDirecotorInNextLoop)//m_bPurgeDirecotorInNextLoop在end()方法中设置为true
    {
        m_bPurgeDirecotorInNextLoop = false;
        purgeDirector();
    }
    else if (! m_bInvalid)
    {
         drawScene();//重点还是drawScene()这个方法
     
         // release the objects
         CCPoolManager::sharedPoolManager()->pop();  //每次回调都要清除下pool池      
    }  	
接下来还是先讨论下关于CCDirector吧。在初始化CCDirector方法中，真正的初始化值是s_SharedDirector，也就是说在CCDirecor包裹了一成皮，里面真正干事的是它的子类CCDisplayLinkDirector，`static CCDisplayLinkDirector *s_SharedDirector = NULL;`  
####CCDirecotr的sharedDirector(void)方法

	if (!s_SharedDirector)
    {
        s_SharedDirector = new CCDisplayLinkDirector();
        s_SharedDirector->init();//实现是在CCDirector中
    }
    return s_SharedDirector;//真正返回的是CCDisplayLinkDirector  
####跟进到CCDirecotr的init()方法
	setDefaultValues();//设置默认初始值，从CCConfiguration中读取初始值

    // 关于scene相关属性
    m_pRunningScene = NULL;//正在运行的场景
    m_pNextScene = NULL;

    m_pNotificationNode = NULL;//可以通过该Node设置悬浮窗或者过渡的节点，该节点不在场景中draw,是单独出来画的

    m_pobScenesStack = new CCArray();
    m_pobScenesStack->init();//初始化保存scene的栈

    // projection delegate if "Custom" projection is used
    m_pProjectionDelegate = NULL;//CCDirectorDelegate类只有当ccDirectorProjection为kCCDirectorProjectionCustom时候才实现运行该类

    // FPS
    m_fAccumDt = 0.0f;
    m_fFrameRate = 0.0f;
    m_pFPSLabel = NULL;
    m_pSPFLabel = NULL;
    m_pDrawsLabel = NULL;
    m_uTotalFrames = m_uFrames = 0;
    m_pszFPS = new char[10];
    m_pLastUpdate = new struct cc_timeval();
    m_fSecondsPerFrame = 0.0f;

    // paused ?
    m_bPaused = false;//在CCDirector::pause(void)设置为true,CCDirector::resume(void)设置为false
   
    // purge ?
    m_bPurgeDirecotorInNextLoop = false;//CCDirector::end()中设置为true

    m_obWinSizeInPoints = CCSizeZero;    

    m_pobOpenGLView = NULL;//CCEGLView

    m_fContentScaleFactor = 1.0f;//缩放因子

    // scheduler
    m_pScheduler = new CCScheduler();//CCScheduler定时调度器，
    // action manager
    m_pActionManager = new CCActionManager();//Action的管理器
    m_pScheduler->scheduleUpdateForTarget(m_pActionManager, kCCPrioritySystem, false);//将CCActionManager根据nPriority>0,-0,<0分别放到_listEntry类型的m_pUpdatesPosList，m_pUpdates0List,m_pUpdatesNegList。具体逻辑都在CCScheduler中的update()方法中，在后文会具体介绍CCScheduler
    // touchDispatcher
    m_pTouchDispatcher = new CCTouchDispatcher();//初始化CCTouchDispatcher，在CCLayer的setToucherEnable()中可以通过CCTouchDispatcher::addStandardDelegate(CCTouchDelegate *pDelegate, int nPriority)或者CCTouchDispatcher::addTargetedDelegate(CCTouchDelegate *pDelegate, int nPriority, bool bSwallowsTouches)方法将CCTouchDelegate注册到CCTouchDispatcher
    m_pTouchDispatcher->init();

    // KeypadDispatcher
    m_pKeypadDispatcher = new CCKeypadDispatcher();//同上，关于实体键

    // Accelerometer
    m_pAccelerometer = new CCAccelerometer();//加速度

    // create autorelease pool
    CCPoolManager::sharedPoolManager()->push();//CCPoolManager管理多个CCAutoreleasePool,将CCAutoreleasePool放到CCPoolManager中的m_pReleasePoolStack

    return true;
好了，也不讲关于CCDirector的初始化了，还是说说drawScene()吧。
####挺近大别山CCDirecotr的drawScene()方法
	 // calculate "global" dt
    calculateDeltaTime();//距离上次main loop的时间

    //tick before glClear: issue #533
    if (! m_bPaused)//如果暂停
    {
        m_pScheduler->update(m_fDeltaTime);//就是刚才在init中所说的CCScheduler的update
    }
    /**glClear（）函数的作用是用当前缓冲区清除值，也就是glClearColor或者glClearDepth、  glClearIndex、glClearStencil、glClearAccum等函数所指定的值来清除指定的缓冲区，也可以使用glDrawBuffer一次清除多个颜色缓存。比如：glClearColor（0.0，0.0，0.0，0.0）;glClear（GL_COLOR_BUFFER_BIT）;第一条语句表示清除颜色设为黑色，第二条语句表示实际完成了把整个窗口清除为黑色的任务，glClear（）的唯一参数表示需要被清除的缓冲区
    **/
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    if (m_pNextScene)
    {
        setNextScene();//初始化场景相关工作，如onEnter()或onExit()
    }

    kmGLPushMatrix();//矩阵压栈

    // draw the scene
    if (m_pRunningScene)
    {
        m_pRunningScene->visit();//遍历正在运行的Scene,先遍历的是CCNode的visit(),因为CCScene没有实现该方法
    }

    // draw the notifications node
    if (m_pNotificationNode)
    {
        m_pNotificationNode->visit();//遍历m_pNotificationNode，可以通过该m_pNotificationNode绘制特殊的节点
    }
    
    if (m_bDisplayStats)
    {
        showStats();//左下角的fps
    }
    
    kmGLPopMatrix();//从矩阵栈中弹出

    m_uTotalFrames++;

    // swap buffers
    if (m_pobOpenGLView)
    {
        m_pobOpenGLView->swapBuffers();
    }
    
    if (m_bDisplayStats)
    {
        calculateMPF();
    }

OpenGL ES 2.0 已经放弃了固定的渲染流水线,取而代之的是自定义 的各种着色器,在这种情况下变换操作通常需要由开发者来维护。所幸引擎也引入了一套第三方库 Kazmath,它使得我们几 乎可以按照原来 OpenGL ES 1.0 所采用的方式进行开发
######Cocos2d-x2.0中矩阵函数的替代函数
![image](../../../../../res/QQ20140429-1.png)